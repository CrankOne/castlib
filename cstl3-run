#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Copyright (c) 2016 Renat R. Dusaev <crank@qcrypt.org>
# Author: Renat R. Dusaev <crank@qcrypt.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function

import sys, ctypes, imp, re
reload(sys)
sys.setdefaultencoding('UTF8')

import argparse, yaml, os, pprint, importlib, pprint, socket, json
from urlparse import urlparse
from collections import OrderedDict

from mem_top import mem_top

from castlib3.filesystem import discover_entries
from castlib3.logs import gLogger
from castlib3.backend import LocalBackend
from castlib3.castor.backend import CASTORBackend
from castlib3.eos.backend import EOSBackend
from castlib3.rpc.reporter import Reporter
from castlib3.exec_utils import configure_cstl3, \
                                ordered_load, \
                                execute_task
# this will cause automatic discovering all castlib3 stages:
import castlib3.stages
from castlib3.syscfg import import_config, gConfig

rxsOverrideOption = r'^(?P<path>[\w\/]+)=(?P<value>[\w.]+)(?:\:(?P<type>\w+))?$'

try:
    from sVresources import yaml
except ImportError:
    import yaml

gExtModules = {}

if '__main__' == __name__:
    p = argparse.ArgumentParser(description="""
    Executable script performing staged routine provided by castlib3 package.
    """)
    p.add_argument('-c', '--configuration'
                , type=str
                , required=True
                , help="Major configuration file (YAML document expected)." )
    p.add_argument('-M', '--mode'
                , type=str, default='development'
                , help="Presets mode name. Corresponds to certain section in "
                "configs (common/development/production/etc).")
    p.add_argument('-L', '--loglevel'  # TODO: use it!
                , default='info'
                , help="Log level with which to run castlib3 routines. Allowed "
                "values are: debug, info, warning, error.")
    p.add_argument('-p','--preload-lib'
                , action='append'
                , help="Preload a shared library within process context. Useful "
                "when running in ancient environments with userspace build.")
    p.add_argument('-m', '--load-module'
                , action='append'
                , help="Load a castlib3 module after initial infrastructure "
                "will be initialized. Use this for customizing stages set "
                "with custom modules. Note: doesn't work yet with python "
                "modules represented by a directory (but works with "
                "ordinary files instead).")
    p.add_argument('-O', '--override'
                , action='append'
                , help='Development feauture. May be a pair in form '
                '"path=value[:type]" where "path" is a slash-separated path '
                'within the stages dict to the '
                'parameter to be overriden, and the type is one of the simple '
                'types to be overriden. If no "type" is given, it will be '
                'assumed a type of original parameter. If no original '
                'parameter is given the type will be assumed being a string.' )
    p.add_argument( '--disable-backend'
                , type=str
                , action='append'
                , help='Backends to be disabled during the run. Overrides ones '
                'provided within configuration file.' )
    p.add_argument( '--disable-location'
                , type=str
                , action='append'
                , help='Locations to be disabled during the run (disables only'
                'ones listed in configuration file).')
    #
    stagesG = p.add_mutually_exclusive_group(required=False)
    stagesG.add_argument( '--omit'
                , action='append'
                , help="Only for --stages. When processing a task as a "
                "pipeline, referes the stages to be omitted from processing." )
    stagesG.add_argument( '--only'
                , action='append'
                , help="Only for --stages. When processing a task as a "
                "pipeline, referes the stages that only have to be executed, "
                "in order." )
    #
    actionG = p.add_mutually_exclusive_group(required=True)
    actionG.add_argument('--list-tasks'
                , action='store_true'
                , help="Will print available tasks discovered within "
                "tasks-locations paths.")
    actionG.add_argument('--list-stages'
                , action='store_true'
                , help="Will print available stages and terminate the script.")
    actionG.add_argument('--list-backends'
                , action='store_true'
                , help="Will print available backends and terminate the script.")
    actionG.add_argument('--stages-file'
                , type=argparse.FileType('r')
                , help="A YAML file describing the task to be performed. "
                "Represented by a YAML file assembling one or more stages "
                "into processing pipeline." )
    actionG.add_argument('--task'
                , type=str
                , help="Runs a task described in stages file in one of the "
                "directories that shall be considered as a system ones. This "
                "mode is pretty similar to --stages-file, but uses internal "
                "tasks registry.")
    actionG.add_argument('--listen'
                , type=str
                , help="Runs script in listening mode. Opens a socket on with "
                "given parameters expecting the incoming stages description. "
                "Once the data arrived, starts the pipeline processing."
                "Expects an addr in form 'localhost:portno'.")
    args = p.parse_args()

    import_config( args.configuration, mode=args.mode )

    if args.list_stages:
        for className, classT in castlib3.stage.gCastlibStages.iteritems():
            print( " * %s%s"%( className, classT.stageDescription ) )
        sys.exit(0)

    if args.list_backends:
        raise NotImplementedError()  # TODO
        sys.exit(0)

    for pl in args.preload_lib or []:
        ctypes.cdll.LoadLibrary(pl)

    for m in args.load_module or []:
        if m.endswith('.py'):
            # This is a path:
            vPath = os.path.split(m)[1]
            vPath = 'castlib3.stages.%s'%os.path.splitext(vPath)[0]
            vPath = str.replace(vPath, '-', '_')
            if vPath not in gExtModules.keys():
                gLogger.info('Loading python source %s as module %s...'%(
                    m, vPath))
                imp.load_source(vPath, m)
                gExtModules[vPath] = m
            else:
                gLogger.warning('Omitting repeatative import of %s.'%vPath)
        else:
            # import module
            if m not in gExtModules.keys():
                gLogger.info('Loading python module %s...'%(m))
                try:
                    gExtModules[m] = importlib.import_module(m, package='castlib3')
                except ImportError as e1:
                    gLogger.info( 'Direct import of "%s" failed. '
                            'Assuming CWD as location.'%m )
                    sys.path.insert(0, os.path.abspath('.'))
                    try:
                        gExtModules[m] = __import__(m)
                    except ImportError as e2:
                        gLogger.error( 'Importing with CWD failed as well. '
                                'Dumping first failure report:' )
                        gLogger.exception( e1 )
                        raise
                    gLogger.info( 'Import of "%s" module succeeded.'%m )
            else:
                gLogger.warning('Omitting repeatative import of %s.'%m)

    gConfig, backends, tr = configure_cstl3( gConfig
                   , disabledBackends=(args.disable_backend or [])
                   , disabledLocations=(args.disable_location or []) )

    if args.list_tasks:
        if not tr.predefinedTasks:
            print( 'No predefined tasks available.' )
            sys.exit(0)
        print('List of pre-defined tasks:')
        for name, dp in tr.predefinedTasks.iteritems():
            tLoc, tDescr = dp
            print( " \"\033[1m%s\033[0m\" (at %s): %s"%( name, tLoc, tDescr ) )
        sys.exit(0)

    if args.stages_file:
        # Parse stages list:
        with args.stages_file as f:
            task = ordered_load(f)
        execute_task( task
                    , omitStages=(args.omit or [])
                    , onlyStages=(args.only or [])
                    , backends=backends
                    , locations=gConfig['locations'] )
        #process_stages( stagesDescription
        #              , noCommit=args.no_commit
        #              , backends=backends )
    elif args.task:
        #with args.stages_file as f:
        #    task = ordered_load(f)
        execute_task( task
                    , omitStages=(args.omit or [])
                    , onlyStages=(args.only or [])
                    , backends=backends
                    , locations=gConfig['locations'] )
    elif args.listen:
        addr, port = args.listen.split(':')
        reporter = Reporter( taskRegistry=tr 
                           , srvAddr=addr
                           , portNo=int(port) )
        reporter.start()
        reporter.stagesCV.acquire()
        try:
            doRun = True
            while doRun:
                while not reporter.stages \
                        or 'stages' not in reporter.stages.keys() \
                        or not reporter.stages['stages'] :
                    reporter.workState = 'Pending.'
                    gLogger.debug( 'Main thread had come to the waiting state.' )
                    # NOTE: for some reason, waiting for CV without a timeout
                    # blocks main thread from receiving the system signals.
                    reporter.stagesCV.wait(timeout=300)
                    reporter.workState = 'Busy.'
                gLogger.info(mem_top())  # XXX
                stgsDescr = reporter.take_stages()
                gLogger.debug( 'Main thread busy.' )
                gLogger.info('Accepted following task '
                        'description: %s'%json.dumps( stgsDescr, indent=2 ))
                doRun = execute_task( stgsDescr
                              , reporter=reporter
                              , backends=backends
                              , locations=gConfig['locations'] )
                gLogger.debug( 'Main has been finished stages.' )
        finally:
            reporter.stagesCV.release()
            gLogger.debug( 'Stopping listener thread...' )
            reporter.alive.clear()
            reporter.sock.shutdown(socket.SHUT_RDWR)
            reporter.join()
    else:
        raise RuntimeError( 'Undefined state: stages/listening port not specified.' )

# vim: filetype=python
