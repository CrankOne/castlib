#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Copyright (c) 2016 Renat R. Dusaev <crank@qcrypt.org>
# Author: Renat R. Dusaev <crank@qcrypt.org>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

from __future__ import print_function

import sys, ctypes, imp
reload(sys)
sys.setdefaultencoding('UTF8')

import argparse, yaml, os, pprint, importlib, pprint, socket
from urlparse import urlparse
from collections import OrderedDict

from castlib3.filesystem import discover_entries
from castlib3.logs import gLogger
from castlib3.backend import LocalBackend
from castlib3.castor.backend import CASTORBackend
from castlib3.rpc import recieve_stages, Reporter
from castlib3.exec_utils import initialize_database, \
                                ordered_load, \
                                discover_locations, \
                                initialize_backends, \
                                process_stages
# this will cause automatic discovering all castlib3 stages:
import castlib3.stages
from castlib3.syscfg import import_config, gConfig

try:
    from sVresources import yaml
except ImportError:
    import yaml

# Standalone run snippet for NA64 superproject:
# $ sources/castlib2/cstl3-run \
#                --db-conf presets.build/configs/db.yml \
#                --stages presets.build/configs/cstl3-tasks/cstl3-spec.yml \
#                --local-path presets.build/byHosts/$(hostname)/cstl3.yml 

gExtModules = {}

if '__main__' == __name__:
    p = argparse.ArgumentParser(description="""
    Executable script performing staged routine provided by castlib3 package.
    """)
    p.add_argument('-c', '--configuration',
                type=str,
                required=True,
                help="Major configuration file (YAML document expected)." )
    p.add_argument('-l', '--location',
                type=str,
                action='append',
                help="This argument has to refer one or more location " \
                "described in the settings config. Their content will be " \
                "then listed and passed to staging pipeline.")
    p.add_argument('-M', '--mode',
                type=str, default='development',
                help="Presets mode name. Corresponds to certain section in " \
                "configs (common/development/production/etc).")
    p.add_argument('-L', '--loglevel',  # TODO: use it!
                default='info',
                help="Log level with which to run castlib3 routines. Allowed " \
                "values are: debug, info, warning, error.")
    p.add_argument('--no-commit',
                action='store_true',
                help="When given no database changes will be actually " \
                "commited. This is a development command helping one to " \
                "check what changes are going to happen. May break the " \
                "staging sequence.")
    p.add_argument('-p','--preload-lib',
                action='append',
                help="Preload a shared library within process context. Useful "\
                "when running in ancient environments with userspace build.")
    p.add_argument('-m', '--load-module',
                action='append',
                help="Load a castlib3 module after initial infrastructure " \
                "will be initialized. Use this for customizing stages set " \
                "with custom modules. Note: doesn't work yet with python "  \
                "modules represented by a directory (but works with " \
                "ordinary files instead).")
    actionG = p.add_mutually_exclusive_group(required=True)
    actionG.add_argument('--list-stages', action='store_true',
                help="Will print available stages and terminate the script.")
    actionG.add_argument('--dry', action='store_true',
                help="Will print directories to index and terminate the script. " \
                "Useful for wildcards inspection.")
    actionG.add_argument('--stages',
                type=argparse.FileType('r'),
                help="A YAML file describing the task to be performed. " \
                "Represented by a YAML file assembling one or more stages " \
                "into processing pipeline." )
    actionG.add_argument('--listen',
                type=str,  # TODO: more doc about format specification
                help="Runs script in listening mode. Opens a socket on with " \
                "given parameters expecting the incoming stages description. " \
                "Once the data arrived, starts the pipeline processing." \
                "Expects an addr in form 'localhost:portno'.")
    args = p.parse_args()

    import_config( args.configuration, mode=args.mode )

    if args.list_stages:
        for className, classT in castlib3.stage.gCastlibStages.iteritems():
            print( " * %s%s"%( className, classT.stageDescription ) )
        sys.exit(0)

    # Shall we make it configurable?
    backends = initialize_backends( gConfig['backends'].keys()
                                  , gConfig['backends'] )  # ...

    for pl in args.preload_lib or []:
        ctypes.cdll.LoadLibrary(pl)

    for m in args.load_module or []:
        if m.endswith('.py'):
            # This is a path:
            vPath = os.path.split(m)[1]
            vPath = 'castlib3.stages.%s'%os.path.splitext(vPath)[0]
            vPath = str.replace(vPath, '-', '_')
            if vPath not in gExtModules.keys():
                gLogger.info('Loading python source %s as module %s...'%(
                    m, vPath))
                imp.load_source(vPath, m)
                gExtModules[vPath] = m
            else:
                gLogger.warning('Omitting repeatative import of %s.'%vPath)
        else:
            # import module
            if m not in gExtModules.keys():
                gLogger.info('Loading python module %s...'%(m))
                gExtModules[m] = importlib.import_module(m, package='castlib3')
            else:
                gLogger.warning('Omitting repeatative import of %s.'%m)

    # Set-up the directory paths.
    directories = {}
    
    if args.location:
        #locs = map( lambda k : gConfig['locations'][k], args.location )
        for l in args.location:
            if l in gConfig['locations']:
                directories[l] = gConfig['locations'][l]
            elif l.endswith('.yml') or l.endswith('.yaml'):
                directories.update(discover_locations( l ))
            else:
                raise TypeError('Location expected to be either a reference to ' \
                        'known locations in global config, or a dedicated .yml ' \
                        'file. Got "%s".'%l )

    # Discover filesystem entries in database, and obtain files list applying
    # wildcards.
    if directories:
        directories = discover_entries( directories, backends=backends )

    # For dry run, just print the content to be indexed and that's it.
    if args.dry:
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint( directories )
        sys.exit(0)

    # Explicitly initialize database, if database config was provided:
    dbConf = gConfig
    initialize_database( gConfig['database'].pop('\\args'),
                         engineCreateKWargs=gConfig['database'] )

    if args.stages:
        # Parse stages list:
        with args.stages as f:
            stages = ordered_load(f)
        process_stages( stages
                      , directories=directories
                      , noCommit=args.no_commit
                      , backends=backends )
    elif args.listen:
        addr, port = args.listen.split(':')
        port = int(port)
        reporter = Reporter(srvAddr=addr, portNo=port)
        reporter.start()
        reporter.stagesCV.acquire()
        try:
            doRun = True
            while doRun:
                while not reporter.stages \
                        or 'stages' not in reporter.stages.keys() \
                        or not reporter.stages['stages'] :
                    gLogger.info( 'Main thread had come to the waiting state.' )
                    # NOTE: for some reason, waiting for CV without a timeout
                    # blocks main thread from receiving the system signals.
                    reporter.stagesCV.wait(timeout=300)
                gLogger.info( 'Main thread busy.' )
                doRun = process_stages( reporter.stages
                              , directories=directories
                              , noCommit=args.no_commit
                              , backends=backends
                              , reporter=reporter )
                gLogger.info( 'Main has been finished stages.' )
        finally:
            reporter.stagesCV.release()
            gLogger.info( 'Stopping listener thread...' )
            reporter.alive.clear()
            reporter.sock.shutdown(socket.SHUT_RDWR)
            reporter.join()
    else:
        raise RuntimeError( 'Undefined state: stages/listening port not specified.' )

# vim: filetype=python
